# Generate a ZK Proof

We'll create a program that proves ownership of a password hash without revealing the password. This example demonstrates a practical use case for zero-knowledge proofs in authentication systems.

## Creating the Project

First, [install the RISC Zero toolchain](https://dev.risczero.com/api/zkvm/install):

1. Install `rzup`:
    ```bash
    curl -L https://risczero.com/install | bash
    ```
2. Run `rzup` to install Risc Zero toolchain:
    ```bash
    rzup install
    ```

3. Create a new project:

    ```bash
    cargo risczero new password_proof --guest-name password_verify
    cd password_proof
    ```

This command scaffolds a new RISC Zero project with the basic structure and necessary dependencies.

## Project Structure

Create a new project with the following structure:

```
password_proof/
├── Cargo.toml           # Workspace configuration
├── host/
│   ├── Cargo.toml      # Host dependencies
│   └── src/
│       └── main.rs     # Host program that runs the zkVM
└── methods/
    ├── guest/
    │   ├── Cargo.toml  # Guest dependencies
    │   └── src/
    │       └── main.rs # Guest program that runs inside zkVM
    └── Cargo.toml
```

## Configuration Files

**1. Workspace Cargo.toml**

The workspace configuration manages all the components of our RISC Zero project. We set optimization levels high even in dev mode because zkVM execution is significantly faster with optimizations:

```toml
[workspace]
resolver = "2"
members = ["host", "methods"]

[profile.dev]
opt-level = 3

[profile.release]
debug = 1
lto = true
```

**2. Host Cargo.toml**

The host program needs several dependencies for proof generation, serialization, and cryptographic operations:

```toml
[package]
name = "host"
version = "0.1.0"
edition = "2021"

[dependencies]
[package]
name = "host"
version = "0.1.0"
edition = "2021"

[dependencies]
methods = { path = "../methods" }
risc0-zkvm = { version = "1.2.1" }
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
serde = "1.0"
serde_json = "1.0"
hex = "0.4"
sha2 = "0.10"
bincode = "1.3"
```

**3. Guest Cargo.toml**

The guest code runs inside the zkVM and needs minimal dependencies. We disable default features to reduce the binary size:

```toml
[package]
name = "password_verify"
version = "0.1.0"
edition = "2021"

[workspace]

[dependencies]
risc0-zkvm = { version = "1.2.1", default-features = false, features = ['std'] }
sha2 = "0.10"
```

## Writing the Code

**1. Guest Program (`methods/guest/src/main.rs`)**

```rust
use risc0_zkvm::guest::env;
use sha2::{Sha256, Digest};

fn main() {
    // Read the password from the host
    let password: String = env::read();

    // Read the expected hash from the host
    let expected_hash: [u8; 32] = env::read();

    // Hash the password
    let mut hasher = Sha256::new();
    hasher.update(password.as_bytes());
    let password_hash = hasher.finalize();

    // Verify the hash matches
    assert_eq!(password_hash[..], expected_hash, "Password hash mismatch!");

    // Commit the hash to the journal (public output)
    // The original password remains private
    env::commit(&expected_hash);
}
```

**2. Host Program (`host/src/main.rs`)**

By default, we use the standard composite receipt type which is suitable for most development scenarios:

```rust
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    PASSWORD_VERIFY_ELF, PASSWORD_VERIFY_ID
};
use serde::Serialize;
use risc0_zkvm::{default_prover, ExecutorEnv};
use sha2::{Sha256, Digest};
use std::fs;

#[derive(Serialize)]
struct ProofData {
    input: String, // Hex string containing receipt and image_id
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

        let password = "my_secret_password";

        // Calculate the password hash
        let mut hasher = Sha256::new();
        hasher.update(password.as_bytes());
        let password_hash: [u8; 32] = hasher.finalize().try_into().unwrap();
    
        // Create the execution environment
        let env = ExecutorEnv::builder()
            .write(&password.to_string())
            .unwrap()
            .write(&password_hash)
            .unwrap()
            .build()
            .unwrap();
    
        // Get the prover
        let prover = default_prover();
    
        // Generate proof (uses composite receipt by default)
        println!("Generating proof...");
  
    
        let receipt = prover
            .prove(env, PASSWORD_VERIFY_ELF)
            .unwrap()
            .receipt;
        
    
        // Prepare proof data for Cartesi
        let receipt_bytes = bincode::serialize(&receipt).unwrap();
        let image_id_bytes: Vec<u8> = PASSWORD_VERIFY_ID
            .iter()
            .flat_map(|&id| id.to_le_bytes().to_vec())
            .collect();
    
        // Combine receipt and image_id
        let mut combined_bytes = Vec::new();
        combined_bytes.extend_from_slice(&receipt_bytes);
        combined_bytes.extend_from_slice(&image_id_bytes);
    
        // Create proof data with hex encoding
        let proof_data = ProofData {
            input: hex::encode(&combined_bytes),
        };
    
          // Log the image ID in the format needed for the verifier
          println!("\n=== COPY THIS IMAGE ID FOR VERIFIER ===");
          println!("const PASSWORD_VERIFY_ID: [u32; 8] = [");
          for (i, &id) in PASSWORD_VERIFY_ID.iter().enumerate() {
              if i < PASSWORD_VERIFY_ID.len() - 1 {
                  println!("    0x{:08x},", id);
              } else {
                  println!("    0x{:08x}", id);
              }
          }
          println!("];");
    
        // Save to file
        fs::write(
            "proof_input.json",
            serde_json::to_string_pretty(&proof_data).unwrap(),
        )
        .unwrap();
    
        println!("\n=== PROOF STATS ===");
        println!("Proof size: {} bytes", combined_bytes.len());
        println!("Hex string length: {} chars", proof_data.input.len());
}

```

## Receipt Types and Proving Options

RISC Zero supports three types of receipts through `ProverOpts`:

```rust
// Default composite receipt
prover.prove(env, ELF_PATH)

// Succinct receipt
prover.prove_with_opts(env, ELF_PATH, &ProverOpts::succinct())

// Groth16 receipt (x86 only)
prover.prove_with_opts(env, ELF_PATH, &ProverOpts::groth16())
```

### Using Groth16 Receipts

For on-chain verification and production deployments, Groth16 receipts are recommended due to their minimal size (a few bytes). To use Groth16:

```rust
let receipt = prover
    .prove_with_opts(env, PASSWORD_ELF, &ProverOpts::groth16())
    .unwrap()
    .receipt;
```

:::important
Groth16 receipt generation requires x86 architecture due to the STARK-to-SNARK prover implementation.
If you're on Apple Silicon or another architecture, you'll **either** need to:

- Use a remote x86 server
- Use the Bonsai proving service
- Use composite or succinct receipts instead
  :::


## Using Bonsai for Remote Proving

For production deployments, we recommend [using Bonsai proving service](https://dev.risczero.com/api/generating-proofs/remote-proving) with Groth16 receipts:

### 1. Configure Bonsai Credentials


```bash
export BONSAI_API_KEY=your_api_key_here
export BONSAI_API_URL=https://api.bonsai.xyz
```

### 2. Generate the proof

```bash
RISC0_DEV_MODE=0 cargo run --release
```

The `default_prover()` function automatically detects these environment variables and uses Bonsai for proving.

### 3. Specify Groth16 Receipts

```rust
// Always use Groth16 receipts for Cartesi integration
let receipt = prover
    .prove_with_opts(env, PASSWORD_ELF, &ProverOpts::groth16())
    .unwrap()
    .receipt;
```

:::tip
We strongly recommend using Groth16 receipts for Cartesi Rollups integration because:

- Much smaller proof size (a few bytes vs >100kb)
- Faster verification time
- Lower resource usage in the Cartesi Machine
- Better scalability for blockchain applications
  :::

## Running the Application

1. Build and run to generate the proof:

```bash
RISC0_DEV_MODE=0 cargo run --release
```

2. Check the generated proof:

```bash
cat proof_input.json
```

The proof demonstrates that we know a password matching a specific hash, without revealing the password itself. This pattern can be extended to various authentication and verification scenarios.

Next, we'll see how to verify this proof inside a Cartesi Rollup.
